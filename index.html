<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>사경 각도 측정 앱</title>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" />
  <style>
    :root {
      --bg: #ffffff;
      --ink: #0f172a;
      --muted: #475569;
      --accent: #0ea5e9;
      --border: #cbd5e1;
    }
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Noto Sans, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
      background: linear-gradient(135deg, #dff9fb, #c7ecee);
      margin: 0;
      padding: 16px;
      display: flex;
      flex-direction: column;
      align-items: center;
      color: var(--ink);
    }
    h1 { margin: 6px 0 2px 0; font-size: 1.2rem; }
    p { margin: 0 0 10px 0; font-size: 0.92rem; color: var(--muted); }
    .file-upload {
      display: inline-flex; align-items: center; gap: 10px; margin: 10px 0 12px 0;
      background: #e0f2fe; padding: 10px 16px; border-radius: 12px; box-shadow: inset 0 1px 3px rgba(0,0,0,0.08);
      cursor: pointer; transition: background 0.2s;
    }
    .file-upload:hover { background: #bae6fd; }
    .file-upload input[type="file"] { display: none; }
    .file-upload span { font-size: 0.95rem; color: #0369a1; }
     .file-upload-group {
      display: flex;          /* 가로 정렬 */
      gap: 12px;              /* 버튼 사이 간격 */
      justify-content: center;/* 가운데 정렬 (왼쪽 정렬 원하면 flex-start) */
}
    canvas {
      border: 2px solid var(--border); border-radius: 16px; background: #fff;
      box-shadow: 0 6px 16px rgba(0,0,0,.08); width: 100%; max-width: 700px; aspect-ratio: 4/3;
      touch-action: none;
 
   

    .buttons { margin-top: 12px; display: flex; flex-wrap: wrap; gap: 10px; }
    button {
      padding: 10px 14px; border: none; border-radius: 10px; font-size: 14px; cursor: pointer; color: #fff;
      display: inline-flex; align-items: center; gap: 6px; transition: transform 0.15s ease; box-shadow: 0 3px 10px rgba(0,0,0,.08);
    }
    button:active { transform: scale(0.97); }
    .undo { background: #334155; }
    .reset { background: #ef4444; }
    .save { background: #22c55e; }
    .toggle { background: #0ea5e9; }
    .help { background: #64748b; }
    @media (prefers-color-scheme: dark) {
      body { background: #111827; }
      canvas { background: #0b1220; }
      h1 { color: #f8fafc; }
      p { color: #cbd5e1; }
      .file-upload { background: #1e293b; }
      .file-upload span { color: #e0f2fe; }
    }
  </style>

  <link rel="manifest" href="manifest.json" />
  <meta name="theme-color" content="#0ea5e9" />
  <link rel="icon" href="icon-192.png" sizes="192x192" />

</head>
<body>
  <h1>사경 각도 측정 앱</h1>
  <p>이미지를 업로드하고 <b>기준선(두 점)</b> → <b>기울기선(두 점)</b>을 탭해 각도를 측정하세요.</p>

<div class="file-upload-group">
  <label class="file-upload">
    <i class="fa fa-camera"></i>
    <span>사진 찍기</span>
    <input type="file" accept="image/*" capture="environment" id="cameraInput" />
  </label>

  <label class="file-upload">
    <i class="fa fa-image"></i>
    <span>앨범에서 선택</span>
    <input type="file" accept="image/*" id="fileInput" />
  </label>
</div>

  <canvas id="canvas"></canvas>

  <div class="buttons">
    <button class="undo" onclick="undoPoint()"><i class="fa fa-undo"></i> Undo</button>
    <button class="reset" onclick="resetCanvas()"><i class="fa fa-rotate-right"></i> Reset</button>
    <button class="save" onclick="saveImage()"><i class="fa fa-save"></i> Save PNG</button>
    <button class="toggle" onclick="toggleProtractor()"><i class="fa fa-circle-half-stroke"></i> 각도계 On/Off</button>
    <button class="help" onclick="toggleHelp()"><i class="fa fa-circle-question"></i> 도움말</button>
  </div>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");

    // ===== 상태 =====
    let pts = []; // 점 최대 4개 [p1, p2, p3, p4]
    let draggingIndex = null; // 드래그 중인 점 인덱스
    let image = null; // 배경 이미지

    // 각도계 표시 여부
    let showProtractor = false;

    // 각도계 상태 (초기 수평: rotation = 0)
    const BASE_RADIUS = 150;
    let protractor = { x: 0, y: 0, radius: BASE_RADIUS, rotation: 0 };

    // 이미지 보기 상태
    let imgScale = 1;
    let imgOffsetX = 0;
    let imgOffsetY = 0;

    // 터치 제스처 상태
    let lastTouchDist = null;
    let lastTouchAngle = null;
    let lastPan = null;

    // ===== 유틸 =====
    function resizeCanvasToDisplaySize(){
      const rect = canvas.getBoundingClientRect();
      canvas.width = rect.width; canvas.height = rect.height;
      if (!protractor.x && !protractor.y){
        protractor.x = canvas.width/2; protractor.y = canvas.height/2;
      }
      draw();
    }

    function getXYFromClient(clientX, clientY){
      const rect = canvas.getBoundingClientRect();
      return { x: (clientX - rect.left), y: (clientY - rect.top) };
    }

    function dist2(a, b){ const dx=a.x-b.x, dy=a.y-b.y; return Math.sqrt(dx*dx + dy*dy); }

    function computeAngle(p1, p2, p3, p4){
      const v1 = {x: p2.x - p1.x, y: p2.y - p1.y};
      const v2 = {x: p4.x - p3.x, y: p4.y - p3.y};
      const dot = v1.x*v2.x + v1.y*v2.y;
      const cross = v1.x*v2.y - v1.y*v2.x;
      const ang = Math.atan2(Math.abs(cross), dot) * 180 / Math.PI; // 0~180
      return ang;
    }

    function angleLabel(){
      if (pts.length === 4){
        const a = computeAngle(pts[0], pts[1], pts[2], pts[3]);
        return `각도: ${a.toFixed(1)}°`;
      }
      if (pts.length === 2){
        return `기준선 설정됨 (점 2개)`;
      }
      return `점을 탭해서 선을 만드세요 (기준선 2개점, 기울기선 2개점)`;
    }

    // ===== 그리기 =====
    function draw(){
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.fillStyle = "#fff"; ctx.fillRect(0, 0, canvas.width, canvas.height);

      // 배경 이미지
      if (image){
        const scale = Math.min(canvas.width / image.width, canvas.height / image.height) * imgScale;
        const dw = image.width * scale; const dh = image.height * scale;
        const dx = (canvas.width - dw) / 2 + imgOffsetX;
        const dy = (canvas.height - dh) / 2 + imgOffsetY;
        ctx.drawImage(image, dx, dy, dw, dh);
      }

      // 선/점
      drawPointsAndLines();

      // 각도 라벨
      const label = angleLabel();
      ctx.font = "14px system-ui";
      const w = ctx.measureText(label).width + 16;
      ctx.fillStyle = "#0ea5e9"; ctx.fillRect(10, 10, w, 26);
      ctx.fillStyle = "#fff"; ctx.fillText(label, 18, 28);

      // 각도계
      if (showProtractor){ drawProtractor(); drawLevelBadge(); }
    }

    function drawPointsAndLines(){
      // 선
      if (pts.length >= 2) drawLine(pts[0], pts[1], "#ef4444"); // 기준선
      if (pts.length >= 4) drawLine(pts[2], pts[3], "#3b82f6"); // 기울기선

      // 점
      pts.forEach((p, i) => {
        ctx.beginPath();
        ctx.arc(p.x, p.y, 8, 0, Math.PI*2);
        ctx.fillStyle = "#111827"; ctx.fill();
        ctx.strokeStyle = "#94a3b8"; ctx.lineWidth = 2; ctx.stroke();
        ctx.fillStyle = "#fff"; ctx.font = "12px system-ui";
        ctx.fillText(String(i+1), p.x - 3, p.y + 4);
      });
    }

    function drawLine(p1, p2, color){
      ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
      ctx.strokeStyle = color; ctx.lineWidth = 3; ctx.stroke();
    }

    function drawProtractor(){
      ctx.save();
      ctx.translate(protractor.x, protractor.y);
      ctx.rotate(protractor.rotation);

      // 반원 테두리
      ctx.strokeStyle = "#000"; ctx.lineWidth = 0.8;
      ctx.beginPath(); ctx.arc(0, 0, protractor.radius, Math.PI, 0, false); ctx.stroke();

      // 눈금: 1° 매우 짧음, 5° 중간, 10° 긴(중심까지), 10°마다 숫자
      ctx.font = "10px system-ui"; ctx.fillStyle = "#000";
      for (let deg = 0; deg <= 180; deg++){
        const rad = deg * Math.PI/180;
        const xOuter = protractor.radius * Math.cos(rad);
        const yOuter = -protractor.radius * Math.sin(rad);

        let innerR = protractor.radius * 0.97; // 1도 기본(매우 짧음)
        if (deg % 10 === 0){ innerR = 0; }          // 중심까지 긴 선
        else if (deg % 5 === 0){ innerR = protractor.radius * 0.85; } // 중간 선

        const xInner = innerR * Math.cos(rad);
        const yInner = -innerR * Math.sin(rad);

        ctx.beginPath(); ctx.moveTo(xInner, yInner); ctx.lineTo(xOuter, yOuter); ctx.stroke();

        if (deg % 10 === 0){
          // 숫자(작게)
          ctx.fillText(String(deg), xOuter - 8, yOuter - 4);
        }
      }
      ctx.restore();
    }

    function drawLevelBadge(){
      // 수평 여부 안내 (rotation이 0 또는 π 근처)
      const r = ((protractor.rotation % Math.PI) + Math.PI) % Math.PI; // [0, π)
      const delta = Math.min(r, Math.PI - r); // 0에 가까우면 수평
      if (delta < (0.1 * Math.PI / 180)){ // 0.1° 이하
        const text = "수평";
        ctx.font = "12px system-ui";
        const w = ctx.measureText(text).width + 10;
        ctx.fillStyle = "#22c55e"; ctx.fillRect(canvas.width - w - 12, 10, w, 22);
        ctx.fillStyle = "#fff"; ctx.fillText(text, canvas.width - w - 6, 26);
      }
    }

    // ===== 상호작용 =====
    function addPointFromCanvasXY(x, y){
      if (pts.length >= 4) pts = [{x, y}];
      else pts.push({x, y});
      draw();
      if (navigator.vibrate) navigator.vibrate(25);
    }

    function hitTestPoint(x, y){
      const p = {x, y};
      for (let i = 0; i < pts.length; i++){
        if (dist2(p, pts[i]) <= 16){ // 반지름 4^2=16 (시각 반지름은 8px)
          return i;
        }
      }
      return null;
    }

    function undoPoint(){ if (pts.length > 0){ pts.pop(); draw(); } }
    function resetCanvas(){ pts = []; imgScale = 1; imgOffsetX = 0; imgOffsetY = 0; protractor.radius = BASE_RADIUS; protractor.rotation = 0; draw(); }
    function saveImage(){
  canvas.toBlob(blob => {
    const file = new File([blob], "angle.png", {type: "image/png"});
    if (navigator.canShare && navigator.canShare({ files: [file] })) {
      navigator.share({
        files: [file],
        title: "사경 각도 측정 결과",
        text: "측정한 이미지를 저장 또는 공유하세요."
      });
    } else {
      const a = document.createElement('a');
      a.download = 'angle.png';
      a.href = URL.createObjectURL(blob);
      a.click();
    }
  });
}
    function toggleProtractor(){ showProtractor = !showProtractor; draw(); }

    // 터치 이벤트
    canvas.addEventListener("touchstart", e => {
      if (e.touches.length === 2){
        // 핀치: protractor On이면 각도계 스케일/회전, Off이면 이미지 스케일/이동
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        lastTouchDist = Math.sqrt(dx*dx + dy*dy);
        lastTouchAngle = Math.atan2(dy, dx);
        lastPan = { x: (e.touches[0].clientX + e.touches[1].clientX)/2, y: (e.touches[0].clientY + e.touches[1].clientY)/2 };
      } else if (e.touches.length === 1){
        const {x, y} = getXYFromClient(e.touches[0].clientX, e.touches[0].clientY);
        const hit = hitTestPoint(x, y);
        if (hit !== null){ draggingIndex = hit; }
        else { lastPan = { x: e.touches[0].clientX, y: e.touches[0].clientY }; }
      }
    }, {passive: true});

    canvas.addEventListener("touchmove", e => {
      if (e.touches.length === 2){
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const dist = Math.sqrt(dx*dx + dy*dy);
        const angle = Math.atan2(dy, dx);

        if (showProtractor){
          // 각도계 조작
          if (lastTouchDist){ protractor.radius *= (dist / lastTouchDist); }
          if (lastTouchAngle !== null){ protractor.rotation += (angle - lastTouchAngle); }
        } else {
          // 이미지 조작
          if (lastTouchDist){ imgScale *= (dist / lastTouchDist); }
          // 투핑거 팬
          const midX = (e.touches[0].clientX + e.touches[1].clientX)/2;
          const midY = (e.touches[0].clientY + e.touches[1].clientY)/2;
          if (lastPan){ imgOffsetX += (midX - lastPan.x); imgOffsetY += (midY - lastPan.y); lastPan = {x: midX, y: midY}; }
        }

        lastTouchDist = dist; lastTouchAngle = angle;
        draw(); if (e.cancelable) e.preventDefault();
      } else if (e.touches.length === 1){
        const touch = e.touches[0];
        const {x, y} = getXYFromClient(touch.clientX, touch.clientY);
        if (draggingIndex !== null){
          pts[draggingIndex] = {x, y}; draw();
        } else if (lastPan){
          // 한 손가락 드래그: protractor On이면 각도계 이동, Off이면 이미지 팬
          const dx = touch.clientX - lastPan.x;
          const dy = touch.clientY - lastPan.y;
          if (showProtractor){ protractor.x += dx; protractor.y += dy; }
          else { imgOffsetX += dx; imgOffsetY += dy; }
          lastPan = {x: touch.clientX, y: touch.clientY}; draw();
        }
        if (e.cancelable) e.preventDefault();
      }
    }, {passive: false});

    canvas.addEventListener("touchend", e => {
      if (e.touches.length === 0){ draggingIndex = null; lastPan = null; lastTouchDist = null; lastTouchAngle = null; }
    });

    // 탭으로 점 추가 (한 번 탭하면 점이 생기고, 두 번째 탭으로 선 완성)
    canvas.addEventListener("click", e => {
      // 두 손가락 제스처 직후의 유령 클릭을 방지하기 위한 간단 보호는 생략
      const {x, y} = getXYFromClient(e.clientX, e.clientY);
      const hit = hitTestPoint(x, y);
      if (hit === null){ addPointFromCanvasXY(x, y); }
    });

    // 데스크톱 마우스 드래그도 지원
    let mouseDown = false;
    canvas.addEventListener("mousedown", e => {
      mouseDown = true; const {x, y} = getXYFromClient(e.clientX, e.clientY);
      const hit = hitTestPoint(x, y); if (hit !== null) draggingIndex = hit; else lastPan = {x: e.clientX, y: e.clientY};
    });
    window.addEventListener("mousemove", e => {
      if (!mouseDown) return; const {x, y} = getXYFromClient(e.clientX, e.clientY);
      if (draggingIndex !== null){ pts[draggingIndex] = {x, y}; draw(); }
      else if (lastPan){ const dx = e.clientX - lastPan.x; const dy = e.clientY - lastPan.y; if (showProtractor){ protractor.x += dx; protractor.y += dy; } else { imgOffsetX += dx; imgOffsetY += dy; } lastPan = {x: e.clientX, y: e.clientY}; draw(); }
    });
    window.addEventListener("mouseup", () => { mouseDown = false; draggingIndex = null; lastPan = null; });

    // 파일 업로드
    document.getElementById("fileInput").addEventListener("change", e => {
      const file = e.target.files[0]; if (!file) return;
      const url = URL.createObjectURL(file);
      const img = new Image();
      img.onload = () => { image = img; URL.revokeObjectURL(url); imgScale = 1; imgOffsetX = 0; imgOffsetY = 0; draw(); };
      img.src = url;
    });

    // 도움말 토글
    let showHelp = false;
    function toggleHelp(){
      showHelp = !showHelp; draw();
      if (showHelp){
        setTimeout(() => { alert(
`사용 방법\n\n1) 화면을 탭해 점 두 개를 만들면 "기준선"이 그려집니다.\n2) 다시 점 두 개를 만들면 "기울기선"이 그려집니다.\n3) 점을 눌러 드래그하면 위치를 조정할 수 있습니다.\n4) 두 손가락으로 이미지 확대/축소 및 이동 (각도계 Off일 때).\n5) 각도계 On일 때는 두 손가락으로 각도계 확대/회전, 한 손가락 드래그로 각도계를 이동합니다.\n6) 상단 파란 상자에 각도 값이 표시됩니다.\n7) 각도계가 수평이 되면 우상단에 "수평" 배지가 나타납니다.`); }, 50);
      }
    }

    // 초기화
    window.addEventListener('resize', resizeCanvasToDisplaySize);
    window.addEventListener('orientationchange', resizeCanvasToDisplaySize);
    requestAnimationFrame(resizeCanvasToDisplaySize);
  </script>

  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./service-worker.js')
          .catch(err => console.error('SW registration failed:', err));
      });
    }
  </script>

</body>
</html>
